# 9.响应式原理-7.queueWatcher

## start

- 看一下英文单词的释义
  - `queue` 队列
  - `Watcher` 观察者
  - `scheduler` 时间调度员；程序机，调度机；调度程序; (存放 `queueWatcher` 方法的 js 文件名)

## 1

```js
/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 * 将一个观察者推入观察者队列。
 * 有重复id的工作将被跳过，除非它是
 * 当队列被刷新时推送。
 */

export function queueWatcher(watcher: Watcher) {
  // 1. 拿到 watcher的id
  const id = watcher.id

  // 2. has 是一个对象， 用来存储 watcher
  if (has[id] == null) {
    has[id] = true

    // flushing 冲洗
    if (!flushing) {
      // queue是一个数组，存储watcher
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      // 如果已经在刷新，则根据监视程序的id拼接它
      // 如果已经超过了它的id，接下来将立即运行它。
      let i = queue.length - 1
      while (i > index && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(i + 1, 0, watcher)
    }
    // queue the flush
    // 排队刷新
    if (!waiting) {
      waiting = true

      if (process.env.NODE_ENV !== 'production' && !config.async) {
        flushSchedulerQueue()
        return
      }
      nextTick(flushSchedulerQueue)
    }
  }
}
```

```js
// 其实就是 下次微任务执行时 更新 dom
export function nextTick(cb?: Function, ctx?: Object) {
  let _resolve
  callbacks.push(() => {
    if (cb) {
      try {
        cb.call(ctx)
      } catch (e) {
        handleError(e, ctx, 'nextTick')
      }
    } else if (_resolve) {
      _resolve(ctx)
    }
  })
  if (!pending) {
    pending = true
    timerFunc()
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise((resolve) => {
      _resolve = resolve
    })
  }
}
```

`queueWatcher` 存储 watcher, 向异步的队列推送我们的 watcher。

其实就是 下次微任务执行时 更新 dom， 遍历并执行 callbacks 的每一项。

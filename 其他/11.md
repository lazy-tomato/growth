# 11 .手写简易版本的 vue2 响应式原理

## start

- 道理我都懂，写我不会写。

## 响应式基础

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vue2 双向数据绑定</title>
</head>

<body>
    </div>
    <script>
        var obj = {
            a: 10,
            b: {
                c: "tomato"
            }
        }

        function defineReactive(obj, key, data) {
            observe(obj[key])

            let dep = new Dep()
            Object.defineProperty(obj, key, {
                get: function () {
                    console.log('get方法执行了,读取字段：' + key,)
                    dep.depend()
                    return data
                },
                set: function (newValue) {
                    console.log('set方法执行了,设置字段：' + key)
                    data = newValue
                    dep.notify()

                }
            })
        }


        function observe(object) {
            if (!obj || typeof object !== 'object') return

            for (const key in object) {
                if (Object.hasOwnProperty.call(object, key)) {
                    defineReactive(object, key, object[key])
                }
            }
        }


        function Dep() {
            this.subs = []
        }
        Dep.prototype.addSubs = function (item) {
            this.subs.push(item)
        }
        Dep.prototype.notify = function () {
            this.subs.forEach(item => {
                console.log(item)
            })
        }
        Dep.prototype.depend = function () {
            if (Dep.target) {
                this.addSub(Dep.target)
            }
        }


        function Watcher(data, exp, callback) {
            this.data = data
            this.exp = exp
            this.callback = callback
            this.value = this.getValue()
        }
        Watcher.prototype.getValue = function () {
            Dep._target = this
            let value = parsePath(this.data, this.exp)
            Dep._target = null
            return value
        }
        Watcher.prototype.update = function () {
            let oldVal = this.value
            this.value = parsePath(this.data, this.exp)
            this.callback.call(this.data, oldVal, this.value)
        }


        function parsePath(obj, expression) {
            const segments = expression.split('.')
            for (let key of segments) {
                if (!obj) return
                obj = obj[key]
            }
            return obj
        }

        observe(obj)

        var wq = new Watcher(obj, 'b.c', function (oldVal, newVal) {
            console.log('旧的', oldVal, '新的', newVal)
        })

        // obj.b.c=123
        // console.dir(obj)
    </script>
</body>

</html>


```

# 6.响应式原理-4.数组的处理方式

## start

- 抛开 Vue 源码不谈，简要说说数组和对象的区别。
- 数组其实是一种特殊的对象：

  - 数组的 key 是数字，例如 0,1,2,3 等

  * 数组原型上有很多数组独有的方法，例如 slice ， psuh ， unshift 等

- 让我们开始看看 Vue 源码对数组的处理。

`Observer`

```js
// 7. 如果是数组 （数组最后再讲，先说对象）
if (Array.isArray(value)) {
  // 7.1 可以使用对象的 __proto__ 属性
  if (hasProto) {
    protoAugment(value, arrayMethods)
  } else {
    // 7.2 不可以使用对象的 __proto__ 属性
    copyAugment(value, arrayMethods, arrayKeys)
  }
  // 7.3执行 observeArray
  this.observeArray(value)
}

// hasProto
export const hasProto = '__proto__' in {}
```

1. 判断是否是数组;
2. 判断是否可以使用 `对象的 __proto__ 属性`;
3. 根据判断执行 `protoAugment` 或者 `copyAugment`;
4. 最后执行 `observeArray`

` protoAugment 或copyAugment`

```js
/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
/**
 * 1.
 * 通过拦截来增强目标对象或数组
 * 使用原型链的 __proto__
 */

// 这里的函数名可以翻译为 原始增加
function protoAugment(target, src: Object) {
  /* eslint-disable no-proto */

  // 2. 这里做的操作就是，把数组的原型指向了我们定义的新对象`arrayMethod` 。新对象的原型是数组正式的原型。
  target.__proto__ = src
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/**
 * 3.
 * 通过定义来扩大目标对象或数组
 * 隐藏属性
 */

/* istanbul ignore next */

// 这里的函数名可以翻译为 拷贝增加
function copyAugment(target: Object, src: Object, keys: Array<string>) {
  // 4. 遍历我们定义的 7 种方法；
  for (let i = 0, l = keys.length; i < l; i++) {
    // 4.1 拿到 方法名
    const key = keys[i]
    // 4.2 给目标数组添加方法，
    def(target, key, src[key])
  }
}
```

1. `protoAugment`：数组的原型指向了我们定义的新对象`arrayMethod`；
2. `copyAugment`：在需要处理的数组上添加我们定义的 7 种方法；
   两个方法本身不难，主要需要做的弄懂传入的参数是什么。

看一下 `arrayMethods, arrayKeys` 这两个传入的参数。

`\src\core\observer\index.js`

```js
import { arrayMethods } from './array'
const arrayKeys = Object.getOwnPropertyNames(arrayMethods)
```

`\src\core\observer\array.js`

```js
/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 * 没有类型检查该文件，因为 flow 不能很好地发挥作用
 * 动态访问数组原型的方法
 */

import { def } from '../util/index'

// 1. 数组的原型
const arrayProto = Array.prototype

// 2. 创建一个对象，原型指向数组的原型  `arrayMethods.__proto__ === Array.prototype` true
export const arrayMethods = Object.create(arrayProto)

// 3. 定义需要处理的数组的方法，这里可以看到改写了 7 种方法；
const methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse',
]

/**
 * Intercept mutating methods and emit events
 */
// 4. 拦截变化的方法并发出事件；
// 遍历我们需要拦截的方法
methodsToPatch.forEach(function (method) {
  // cache original method
  // 5. 缓存 原本数组身上的方法，用来后续调用
  const original = arrayProto[method]

  // 6. 在 arrayMethods上;  定义push，pop，shift，unshift，splice，sort，reverse方法;
  def(arrayMethods, method, function mutator(...args) {
    // 7. 先触发 数组原本对应方法
    const result = original.apply(this, args)

    // 8. 获取到 数据实例上的 Observer实例。
    const ob = this.__ob__
    let inserted // inserted : 插入项

    // 9. 选择方法
    switch (method) {
      case 'push':
      case 'unshift':
        // 9.1 push  unshift 传入的参数都是需要存入数组的参数，所以直接 =
        inserted = args
        break
      case 'splice':
        // 9.2 splice 参数依次为 ①从何处处理 ②处理多少 ③要添加到数组的新元素 ，所以这里取第二个参数以后的参数。
        inserted = args.slice(2)
        break
    }

    // 10. 有新添加来的数据，需要处理成响应式的
    if (inserted) ob.observeArray(inserted)

    // notify change
    // 11. 通知更改
    // 这个地方着重注意一下，我们自身实现数组的 7 种方法，使用它们的时候，也会触发视图更新，根本原因，就是因为这里`ob.dep.notify();`
    ob.dep.notify()

    // 12. result存储的是什么？ 存储的是数组本身对应的方法
    return result
  })

  /* 
  所以最终返回的arrayMethod如下：
    {
      pop: ƒ mutator(...args)
      push: ƒ mutator(...args)
      reverse: ƒ mutator(...args)
      shift: ƒ mutator(...args)
      sort: ƒ mutator(...args)
      splice: ƒ mutator(...args)
      unshift: ƒ mutator(...args)
    }
  */
})
```

整体代码看下来，就返回了一个对象，`arrayMethods`,。
该对象有这么几个特点：

1. 7 个数组方法名，作为 key 值；
2. 原型指向数组的原型，`arrayMethods.__proto__ === Array.prototype`;
3. 本质上是，拿到数组原本的方法，在原本方法的基础上，包一层，处理新添加进来的数据(`ob.observeArray(inserted)`); 通知更新`ob.dep.notify()`

> 需要注意的是 ，这里的通知更新借助了数据上的`__ob__`属性来访问 dep 从而通知更新。这就是`__ob__`存储了`Observer实例`的作用之一。

上述代码，就是对数组**方法**的处理，后续还有数组每一项的处理`observeArray`。

`observeArray`

```js
/**
 * Observe a list of Array items.
 */
// 11.观察Array项
observeArray(items: Array<any>) {
  // 12. 遍历数组的每一项，全部都observe一下。
  for (let i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
}
```

这里主要是遍历数组，给每一项做`observe()`。
但是有一点需要注意：
例如数组
`['张三', '李四', '王五']`
可以看做这样的一个对象
`{0:'张三',1:'李四',2:'王五'}`

出于对性能的考虑，对数组的索引，并没有通过`Object.defineProperty`处理。

## 疑问

### 解答之前的疑问

5.1 数组的响应式处理方式？

> - `observe` 数组每一项的值；
> - 重写数组自带的 7 种方法，调用时： 1. 利用`observeArray`处理新增的项，2.利用 `__ob__.dep.notify`来通知更新；
>   5.2 为什么要给我们的数据绑定一个`__ob__`属性？
>   `__ob__`上存储的是 `Observer实例`;
>   `Observer实例`上又有 存储着依赖的 `dep`
>   绑定了`__ob__`属性，方便我们在代码中手动触发`__ob__.dep.notify`来通知更新。(例如：处理数组的方法，就有具体的使用案例)

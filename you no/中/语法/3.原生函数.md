3. 原生函数
   原生函数例如： `String() Number()`

   注意

   ```js
   var s = new String('123')
   console.dir(s)
   // 0: "1"
   // 1: "2"
   // 2: "3"
   // length: 3
   // [[Prototype]]: String
   // [[PrimitiveValue]]: "123"
   ```

   _new String()生成的是一个字符串的包装对象。_

   ### 3.1 `[[class]]`

   所有 typeof 为 `object`的对象，都有 `[[class]]` 这么一个属性。

   ```js
   console.log(Object.prototype.toString.call([1, 2, 3])) // [object Array]

   console.log(Object.prototype.toString.call(() => {})) // [object Function]

   // 基础类型的数据，也会被包装，所以下方的案例：
   console.log(Object.prototype.toString.call('123')) // [object String]

   // `[[class]]` 存储的就是案例的  Array Function
   // null undefined 同样适用。
   ```

   es5 和 es6 有变动，需要注意

   ### 3.2 封装对象包装

   - 基本类型是没有 `.toString .length` 这些方法的。但是 js 引擎对这种情况做了优化，会自动封装一个对象。

   - 注意：

   ```js
   var a = new Boolean(false)

   if (!a) {
     console.log('执行不到这里')
     // 执行不到这里，包装完，返回的是一个对象
   }
   ```

   - `Object()`同样可以包装对象。

   ### 3.3 拆封

   - 想拿到封装对象中的基本类型值，可以使用 `valueOf()`

   ```js
   var a = Object(false)
   if (!a.valueOf()) {
     console.log('可以执行到这里')
   }

   // 可以执行到这里
   ```

   - 某些使用封装对象的时候，会强制转换。

   ### 3.4 原生函数当做构造函数

   使用原生函数当做构造函数，是有一些意外情况的。

   1. Array()

      - 当做构造函数，可以省略 `new`;

      ```js
      var a = Array(1, 2, 3)
      console.log(a)

      // [1,2,3]
      ```

      - 如果只传入一个数字参数，它会把这个参数当做 `length`; **这有坑啊**

      ```js
      var a = Array(4)
      console.log(a)

      // [ <4 empty items> ]

      // 数组中至少包含一个空单元，我们就称呼它为 `稀疏数组` ；
      ```

      - 稀疏数组，会有一些异常表现，例如上述的示例，在浏览器中有的表示是空，有的表示为 undefined。尽量避免使用此类数组。

   2. `Object() Function() RegExp()`
      - 不到万不得已，否则尽量不用使用上述三个函数;
      - 表达式创建对应对象的方式更加简洁，执行效率高。
   3. `Date() Error()`
   4. `Symbol()`
   5. 原生原型

小节

逐一介绍了这些原生函数，给我的感受就是，原生函数如果当做构造函数的话，使用起来应当小心谨慎。相对来说，字面量的形式或许更佳。

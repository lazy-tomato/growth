# computed

先看看 computed 的源码,computed 的初始化是在 `_init`中的 `initState`。 `\src\core\instance\state.js`

```js
var computedWatcherOptions = { lazy: true }

function initComputed(vm, computed) {
  // 1. 在组件上定义一个 `_computedWatchers` 对象，用来存储这个组件的所有计算属性
  var watchers = (vm._computedWatchers = Object.create(null))
  var isSSR = isServerRendering() // 是服务端渲染

  // 2. 遍历传入的 computed， (选项 computed 是一个对象类型)
  for (var key in computed) {
    var userDef = computed[key]

    // 3. 定义一个变量 getter ， 如果 computed 中属性的属性值是函数，则 getter = 属性值，否则存储属性值的 get；
    var getter = typeof userDef === 'function' ? userDef : userDef.get
    if (getter == null) {
      warn('Getter is missing for computed property "' + key + '".', vm)
    }

    if (!isSSR) {
      // 4. 每一个计算属性，都会创 `new Watcher()`，这里注意两点：1.传入了配置` { lazy: true }`; 2.传入了自定义的 getter；
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      )
    }
    // 5. 排除 key 重复的情况，执行`defineComputed`。
    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else {
      if (key in vm.$data) {
        warn(
          'The computed property "' + key + '" is already defined in data.',
          vm
        )
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(
          'The computed property "' + key + '" is already defined as a prop.',
          vm
        )
      } else if (vm.$options.methods && key in vm.$options.methods) {
        warn(
          'The computed property "' + key + '" is already defined as a method.',
          vm
        )
      }
    }
  }
}
```

1. 在组件实例上定义一个属性 `_computedWatchers` ，存储这个组件的所有计算属性；
2. 遍历传入的 `computed` 选项；

   > 注意 `computed` 选项是一个对象，以后写代码的时候不要混淆了

   - 定义一个变量 getter ， 如果 computed 中属性的属性值是函数，则 getter = 属性值，否则存储属性值的 get；

     > 这行代码，就实现了计算属性的两种写法。
     >
     > 1. 计算属性直接是一个函数的写法
     > 2. 计算属性是对象，可以定义 `get`，`set`属性；

   - 每一个计算属性，都会创 `new Watcher()`，这里注意两点：1.传入了配置` { lazy: true }`; 2.传入了自定义的 getter；
   - 在排除 key 重复的情况，执行`defineComputed`。

### 创建一个 Watcher

计算属性的 `new Watcher()` 有哪些特殊操作？

`1. 使用案例：`

```html
<script src="./vue.js"></script>
<script>
  new Vue({
    el: '#app',
    data() {
      return {
        name: 'lazy',
      }
    },
    computed: {
      tomato() {
        return this.name.toUpperCase()
      },
    },
  })
</script>
```

`2. computed初始化的时候：`

```js
watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions)

// 可以转换为
// watchers['tomato'] = new Watcher(
//   vm,
//   tomato() => {
//     return this.name.toUpperCase()
//   },
//   noop,
//   { lazy: true }
// )
```

`3. Watcher构造函数：`

```js
var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm
  if (isRenderWatcher) {
    vm._watcher = this
  }
  vm._watchers.push(this)
  // options
  if (options) {
    this.deep = !!options.deep
    this.user = !!options.user
    this.lazy = !!options.lazy
    this.sync = !!options.sync
    this.before = options.before
  } else {
    this.deep = this.user = this.lazy = this.sync = false
  }
  this.cb = cb
  this.id = ++uid$1 // uid for batching
  this.active = true
  this.dirty = this.lazy // for lazy watchers
  this.deps = []
  this.newDeps = []
  this.depIds = new _Set()
  this.newDepIds = new _Set()
  this.expression = expOrFn.toString()
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn
  } else {
    this.getter = parsePath(expOrFn)
    if (!this.getter) {
      this.getter = noop
      warn(
        'Failed watching path: "' +
          expOrFn +
          '" ' +
          'Watcher only accepts simple dot-delimited paths. ' +
          'For full control, use a function instead.',
        vm
      )
    }
  }
  this.value = this.lazy ? undefined : this.get()
}
```

` 4. 最终得到的 watcher实例：`

```js
var w1 = {
  active: true,
  dirty: true,
  expression: "tommto () {\n          return '132'\n        }",
  getter: function tommto() {
    return this.name.toUpperCase()
  },
  id: 1,
  lazy: true,
  sync: false,
  user: false,
  value: undefined,
}
```

整理一下上述的逻辑，总的来说就是实例化了一个 `watcher实例`。
但是这个 `watcher实例` 有点特殊:

1. 属性：`getter` 是自己定义的函数；
2. 属性：`dirty` 是`true`；
3. 属性：`lazy` 是`true`；
4. 属性：`value` 是 `undefined`；

注意 `value` 默认是空的。
这些属性后续都会使用到。

### defineComputed

watcher 实例完毕之后，就开始执行 `defineComputed`：

`源码：`

```js
function noop(a, b, c) {}

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop,
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // 需要重新计算
      if (watcher.dirty) {
        watcher.evaluate()
      }

      // 收集依赖
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}

// 参数，新增this
function createGetterInvoker(fn) {
  return function computedGetter() {
    return fn.call(this, this)
  }
}

function defineComputed(target, key, userDef) {
  // 不是服务端渲染，则需要缓存。
  var shouldCache = !isServerRendering()

  // 属性值为函数的情况
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    sharedPropertyDefinition.set = noop
  } else {
    // 属性值不为函数的情况
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop
    sharedPropertyDefinition.set = userDef.set || noop
  }

  // 异常情况处理
  if (sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        'Computed property "' + key + '" was assigned to but it has no setter.',
        this
      )
    }
  }

  // 5. 在组件实例上存储这个计算属性。
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

#### userDef 为函数的情况

我们不是服务端渲染，所以 `shouldCache` 为 `true`，表示需要缓存。然后将上述代码，`userDef` 为函数的情况，精简成如下代码。

```js
function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key]
    if (watcher) {
      // 需要重新计算
      if (watcher.dirty) {
        watcher.evaluate()
      }

      // 收集依赖
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}

/* 精简成下方的代码： (其实就是在组件上绑定我们的计算属性)*/
const obj = {}
obj.get = createComputedGetter(key)
obj.set = noop
Object.defineProperty(target, key, obj)
```

比如说：

```html
<div id="app">
  <div>{{ tomato }}</div>
</div>
<script src="./vue.js"></script>
<script>
  new Vue({
    el: '#app',
    data() {
      return {
        name: 'lazy',
      }
    },
    computed: {
      tomato() {
        return this.name.toUpperCase()
      },
    },
  })
</script>
```

在 `new Vue()` 的时候，会先走计算属性的初始化逻辑。

当页面开始使用 `tomato` 这个计算属性的时候，会触发 `computedGetter` 函数。

- 拿到计算属性的 `watcher`。
- `watcher.dirty` 默认是为 true 的。所以此时会执行`watcher.evaluate()`

```js
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get()
  this.dirty = false
}
```

- `watcher.evaluate()`会执行我计算属性 `watcher`上的`get`;`dirty`改为 false。

name 属性的 dep 会存储 这个计算属性的 tomato

## start

- 浏览器的缓存，主要分为一下四种：

1. Memory Cache
2. Service Worker Cache
3. HTTP Cache
4. Push Cache

## 1. HTTP 缓存

HTTP 缓存是我们日常开发中最为熟悉的一种缓存机制。

它又分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。

### 1.1 强缓存

强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。

实现强缓存，过去我们一直用 expires。
当服务器返回响应时，在 Response Headers 中将过期时间写入 expires 字段。

expires 是一个时间戳

expires 允许我们通过绝对的时间戳来控制缓存过期时间;
Cache-Control 中的 max-age 字段也允许我们通过设定相对的时间长度来达到同样的目的;

> 在 HTTP1.1 标准试图将缓存相关配置收敛进 Cache-Control 这样的大背景下， max-age 可以视作是对 expires 能力的补位/替换。在当下的前端实践里，我们普遍会倾向于使用 max-age。但如果你的应用对向下兼容有强诉求，那么 expires 仍然是不可缺少的。

> Cache-Control 的 max-age 配置项相对于 expires 的优先级更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。

https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2018/9/20/165f701820fafcf8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp

## 2. MemoryCache

MemoryCache，是指存在内存中的缓存。它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。

Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。

## 3 Service Worker Cache

Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。

## Push Cache

Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。
Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。
不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。

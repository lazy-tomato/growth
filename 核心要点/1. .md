# 1. 响应式原理.md

结合 vue@2.6.14 的源码，学习一下相关主干逻辑。

## 梳理一下基本的逻辑

1. new Vue()

2. `this._init()`

3. `this.initState(vm)`

4. `tihs.initData`

5. `observe()`

核心就是看看这个 observe(),响应式原理就是在这个文件夹中。

`src\core\observer\index.js`

`observe`

```js
/*
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */

/**
 * 1.
 * 尝试为一个值创建一个观察者实例
 * 如果成功观察，返回新的观察者
 * 或现有的观察者，如果值已经有一个。
 */

// 2. 调用的时候 observe(data, true /* asRootData */);
export function observe(value: any, asRootData: ?boolean): Observer | void {
  // 3. value 需要处理的数据，作为根数据

  // 4. 如果不是对象，如果是虚拟DOM。直接 return。 （这里需要注意，虚拟dom没有做响应式节约性能）
  if (!isObject(value) || value instanceof VNode) {
    return
  }

  // 5. 定义一个变量 ob ，类型是Observer或者void
  let ob: Observer | void

  // 6. hasOwn：value自身的属性上是否有 '__ob__' , 而且 value.__ob__是 Observer的实例
  // 简单来说：已经是响应式的，直接复用。
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__
  } else if (
    // 7. 需要监听；不是服务端渲染；是数组 或者 普通对象 ；可扩展；_isVue为false
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    // 8. new Observer(value)，传入的值为 我们的data
    ob = new Observer(value)
  }

  // 如果是asRootData，添加计数vmCount
  if (asRootData && ob) {
    ob.vmCount++
  }

  // 10.返回 ob
  return ob
}

// 是否是普通对象
export function isPlainObject(obj: any): boolean {
  return _toString.call(obj) === '[object Object]'
}

// 是自身的属性
const hasOwnProperty = Object.prototype.hasOwnProperty
export function hasOwn(obj: Object | Array<*>, key: string): boolean {
  return hasOwnProperty.call(obj, key)
}
```

`Observer`

```js
/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */

/**
 * 1.
 * 每个被观察对象附加的观察者类
 * 对象。一旦连接上，观察者将转换目标
 * 对象的属性键到getter/setter
 * 收集依赖关系并分发更新。
 */
export class Observer {
  // 2. class直接定义变量， 相当于 function Observer(){}  ;Observer.value;Observer.dep; Observer.vmCount;
  value: any
  dep: Dep
  vmCount: number // number of vms that have this object as root $data

  constructor(value: any) {
    // 3.存储 value
    this.value = value

    // 4.创建一个依赖收集者
    this.dep = new Dep()

    // 5. 计数 把这个数据当成根data对象的实例数量
    this.vmCount = 0

    // 6. 给 data 设置一个 __ob__ 属性，值为 Observer 实例
    // 这个地方可以知道为什么我们 Vue中的数据，打印出来会带有 '__ob__'
    def(value, '__ob__', this)

    // 7. 如果是数组 （数组最后再讲，先说对象）
    if (Array.isArray(value)) {
      // 7.1 可以使用对象的 __proto__ 属性
      if (hasProto) {
        protoAugment(value, arrayMethods)
      } else {
        // 7.2 不可以使用对象的 __proto__ 属性
        copyAugment(value, arrayMethods, arrayKeys)
      }
      // 7.3执行 observeArray
      this.observeArray(value)
    } else {
      // 8. 其他情况，对象
      this.walk(value)
    }
  }

  /**
   * Walk through all properties and convert them into
   * getter/setters. This method should only be called when
   * value type is Object.
   */

  /**
   * 9.
   * 遍历所有属性并将其转换为
   * getter setter。此方法只应在以下情况调用
   * 值类型为Object。
   */

  walk(obj: Object) {
    // 10. 调用对象的属性，循环执行 defineReactive(对象, 对象的属性名)
    const keys = Object.keys(obj)
    for (let i = 0; i < keys.length; i++) {
      defineReactive(obj, keys[i])
    }
  }
}

// 设置一个对象的属性
export function def(obj: Object, key: string, val: any, enumerable?: boolean) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable, // 是否可枚举 （可枚举就是能被 for in遍历）
    writable: true, // 是否可写
    configurable: true, // 是否可以改变，是否可删除
  })
}

// 一个对象的 __proto__ 属性指向了其构造函数的原型； 作用： 检查当前环境是否可以使用对象的 __proto__ 属性
export const hasProto = '__proto__' in {}
```

`defineReactive`

1. new Vue()

2. `this._init()`

3. `this.initState(vm)`

4. `tihs.initData`

5. `observe()`

整个思路梳理一下

首先第一步 在初始化数据的时候， initData 会调用入口 observe

observe 实际上是 new Observer()

需要注意的是

1. 会给传入的对象绑定一个 `__ob__` 属性
2. Observer 本质是区分数组和对象

对象的话给对象每一项，执行 defineReactive 。
实际上就是 Object.defineProperty, new dep()，在 get 中收集依赖 dep.depend()，在 set 中触发依赖 dep.notify();

数组的话，修改数组的原型对象为我们新增的一个对象，重写了七个方法
"push",
"pop",
"shift",
"unshift",
"unshift",
"sort",
"reverse",

除了执行函数方法本身之外 original

做了两个事情

1. 如果是加了数据，例如 push unshift unshift， 对新增加的数据做一下啊响应式追踪
2. 触发了这起个方法，手动通知所有的观察者，进行修改 ob.dep.notify();
   > 注意一下，这里的 ob 就是我们事先存储在数据的属性 `__ob__` 上·
   > 看书有一个好玩的地方，通过索引修改数组，不触发通知 我们手动 `__ob__.dep.notify()`

除此之外，有一个地方需要注意
传入的数据 `let data = vm.$options.data; ` 随即绑定到`vm._data`上，然后对着数据做 observe 处理，但是还有一个细节 `vm._data`使用数据很不方便，不符合我们的使用习惯

直接代理到 this 上
`proxy(vm, `\_data`, key);`

```js
// 代理 `vm.xxxProps 或者 this.xxxProps` 实际上访问的是=> `vm._props.xxxProps`
export function proxy(target: Object, sourceKey: string, key: string) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key]
  }
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}
```

这一步，主要核心 Object.defineProperty。 get 收集依赖， set 数据触发，
重写数组的方法；
